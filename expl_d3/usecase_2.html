<!DOCTYPE html>
<meta charset="utf-8">
<style>

.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

circle {
  fill: #ccc;
  stroke: #333;
  stroke-width: 1.5px;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}

/* value="1F1tAaz5x1HUXrCNLbtMDqcw6o5GNn4xqX"> */

</style>
<body>
  <p>
    <label >Addr:</label>
    <input id="addrEdit" type="text" size="80"
      value="1F1tAaz5x1HUXrCNLbtMDqcw6o5GNn4xqX">
    <input id="addButton" type="button" size="10" value=" Add "> 
  </p>
  <!-- 3FUQDka2kormn3Ba9UnBeZyjktqL8kgkw5 -->
  <!-- 1UeHTYekppWtmtFuBk7anQfi35gDq3SBm -->
  
</body>

<script src="http:\\d3js.org/d3.v3.min.js"></script>
<script>

var links = []
var nodes = {};

var width = 1100,
    height = 600;

var force = d3.layout.force()
    .nodes(d3.values(nodes))
    .links(links)
    .size([width, height])
    .linkDistance(60)
    .charge(-300)
    .on("tick", tick)
    .start();

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .call(d3.behavior.zoom().on("zoom", function () {
      svg.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")")
    }))
    .append("g")

// Per-type markers, as they don't inherit styles.
svg.append("defs").selectAll("marker")
    .data(["suit", "licensing", "resolved"])
  .enter().append("marker")
    .attr("id", function(d) { return d; })
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 15)
    .attr("refY", -1.5)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("path")
    .attr("d", "M0,-5L10,0L0,5");

var path = svg.append("g").selectAll("path")
    .data(force.links())
  .enter().append("path")
    .attr("class", function(d) { return "link " + d.type; })
    .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });

var circle = svg.append("g").selectAll("circle")
    .data(force.nodes())
  .enter().append("circle")
    .attr("class", function(d) { return "node. " + d.type; })
    .call(force.drag)
    .on("click", handleMouseClick);

var text = svg.append("g").selectAll("text")
    .data(force.nodes())
  .enter().append("text")
    .attr("x", 8)
    .attr("y", ".31em")
    .text(function(d) { return d.name; });


// Use elliptical arc path segments to doubly-encode directionality.
function tick() {
  path.attr("d", linkArc);
  svg.selectAll(".node").attr("transform", transform);
  text.attr("transform", transform);
}

function linkArc(d) {
  var dx = d.target.x - d.source.x,
      dy = d.target.y - d.source.y,
      dr = Math.sqrt(dx * dx + dy * dy);
  return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
}

function transform(d) {
  return "translate(" + d.x + "," + d.y + ")";
}

document.getElementById("addButton").onclick = function() {
  addrAdd(document.getElementById("addrEdit").value);
  // console.log(force.nodes())
}

function handleMouseClick(d, i) {  
    list = force.nodes() 
    addrAdd(list[i].name)  
    restart();
}
function restart() {

  circle = circle.data(force.nodes());
  circle.enter().append("circle")
    .attr("class", function(d) { return "node " + d.type; })
    .attr("r", 6)
    .call(force.drag)
    .on("click", handleMouseClick);  

  path = path.data(force.links());
  path.enter().append("path")
    .attr("class", function(d) { return "link " + d.type; })
    .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });

  text = text.data(force.nodes());
  text.enter()
    .append("text")
    .attr("x", 8)
    .attr("y", ".31em")
    .text(function(d) { if (d.name.length > 10){return d.name.substr(0, 5) + "..." + d.name.substr(d.name.length - 5, d.name.length);} else return d.name });

  force.start();
}

function addrAdd(addrToAdd){
  const url = "http://81.25.55.217:6033/addr/?addr="+addrToAdd;

  // console.log(url)
  const request = async () => {
    const res = await fetch(url)
    const data = await res.json();
    i = 0;
    for (var el of data){
      // console.log(el.tx_dst)
      txAdd(el.tx_dst)
      if (i++ >= 1000) break;
      // i++;
    } 
  }

  request();
}

function txAdd(txToAdd){

  const url = "http://81.25.55.217:6033/tx/?tx="+txToAdd;

  // console.log(url)
  const request = async () => {
    const res = await fetch(url)
    const data = await res.json();
    
    i = 0;
    for (var el of data.vout){ 
      if (i++ > 165) break;
      // i++;
      console.log(el) // .scriptPubKey.address
      if (addrNodeExist(String(el.scriptPubKey.address)) == -1){
        newNode = {name: String(el.scriptPubKey.address), type: "", tx_src: data.txid, n: el.n, weight: 1.0, x: 0.0, y: 0.0}
        force.nodes().push(newNode);
        force.start();
      }
    }
    force.start();
    

    i = 0, j = 0;
    for (var el of data.vin){
      console.log(el)
      if (i++ > 165) break;
      // i++;
      nInd = addrNodeExist(String(el.addr));
      if (nInd == -1){
        newNode = {name: String(el.addr), type: "", weight: 1.0, x: 0.0, y: 0.0}
        nInd = force.nodes().push(newNode);
        force.start();
        nInd = nInd - 1;
      }
      j = 0;
      for (var el2 of data.vout){ 
        if (j++ > 165) break;
        // j++;
        nInd2 = addrNodeExist(String(el2.scriptPubKey.address))
        console.log(nInd, nInd2)
        links.push({source: nInd, target: nInd2});
      }
    }
    // force.start();
    restart();
  }
  request();
}

function addrNodeExist(addr){
  var i;
  var list = force.nodes();

  // console.log(addr)
  for (i = 0; i < list.length; i++) {
    if (list[i].name == addr) {
      // console.log("found", list[i], list[i].index)
      return list[i].index;
    }
  }
  
  // console.log("not found")
  return -1;
}
</script>
