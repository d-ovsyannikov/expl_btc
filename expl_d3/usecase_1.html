<!DOCTYPE html>
<meta charset="utf-8">
<style>

.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

#licensing {
  fill: green;
}

.link.licensing {
  stroke: green;
}

.link.resolved {
  stroke-dasharray: 0,2 1;
}

circle {
  fill: #ccc;
  stroke: #333;
  stroke-width: 1.5px;
}

.node.utxo {
  fill: #ccc;
  stroke: black;
  stroke-width: 1.5px;
  r: 5;
}

.node.notfound {
  fill: red;
  stroke: black;
  stroke-width: 1.5px;
  r: 5;
}

.node.found {
  fill: green;
  stroke: black;
  stroke-width: 1.5px;
  r: 5;
}

.node.tx {
  fill: yellow;
  stroke: black;
  stroke-width: 1.5px;
  r: 5;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}

</style>
<body>
  <p>
    <label >TX id:</label>
    <input id="txEdit" type="text" size="80"
      value="735edf637d7665ff5458d5fa5300d894324dc1579cf6ffaac4cb09655d4e0504">
    <input id="addButton" type="button" size="10" value=" Add "> 
  </p>

</body>

<script src="http:\\d3js.org/d3.v3.min.js"></script>
<script>

var links = []
var nodes = {};

var width = 1100,
    height = 600;

var force = d3.layout.force()
    .nodes(d3.values(nodes))
    .links(links)
    .size([width, height])
    .linkDistance(60)
    .charge(-300)
    .on("tick", tick)
    .start();

var svg = d3.select("body").append("svg")
    // .attr("viewBox", [-width / 2, -height / 2, width, height]);
    .attr("width", width)
    .attr("height", height)
    // .attr("width", "100%")
    // .attr("height", "100%")
    .call(d3.behavior.zoom().on("zoom", function () {
      svg.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")")
    }))
    .append("g")

// Per-type markers, as they don't inherit styles.
svg.append("defs").selectAll("marker")
    .data(["suit", "licensing", "resolved"])
  .enter().append("marker")
    .attr("id", function(d) { return d; })
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 15)
    .attr("refY", -1.5)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("path")
    .attr("d", "M0,-5L10,0L0,5");

var path = svg.append("g").selectAll("path")
    .data(force.links())
  .enter().append("path")
    .attr("class", function(d) { return "link " + d.type; })
    .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });

var circle = svg.append("g").selectAll("circle")
    .data(force.nodes())
  .enter().append("circle")
    .attr("class", function(d) { return "node. " + d.type; })
    // .attr("r", 6)
    .call(force.drag)
    .on("click", handleMouseClick);

// var nodeSymb = svg.append("g").selectAll(".node")
//     .data(force.nodes())
//     .enter()
//     .append("path")
//     .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
//     .attr("d", d3.svg.symbol()
//     .type(d3.symbolSquare)
//     .size(5))
//     .attr("class", function(d) { return "node " + d.type; })
//     // // .style("fill", "steelblue")
//     // .style("stroke", "white")
//     // .style("stroke-width", "1.5px")
//     .call(force.drag)
//     .on("click", handleMouseClick);

var text = svg.append("g").selectAll("text")
    .data(force.nodes())
  .enter().append("text")
    .attr("x", 8)
    .attr("y", ".31em")
    .text(function(d) { return d.name; });


// Use elliptical arc path segments to doubly-encode directionality.
function tick() {
  path.attr("d", linkArc);
  // svg.selectAll("circle").attr("transform", transform);
  svg.selectAll(".node").attr("transform", transform);
  text.attr("transform", transform);
}

function linkArc(d) {
  var dx = d.target.x - d.source.x,
      dy = d.target.y - d.source.y,
      dr = Math.sqrt(dx * dx + dy * dy);
  return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
}

function transform(d) {
  return "translate(" + d.x + "," + d.y + ")";
}

document.getElementById("addButton").onclick = function() {
  txAdd(document.getElementById("txEdit").value);
  console.log(force.nodes())
}

function handleMouseClick(d, i) {  
    list = force.nodes() 
    if (list[i].tx_dst != ""){
      txAdd(list[i].tx_dst)
    }
    if (list[i].tx_src != ""){
      txAdd(list[i].tx_src)
    }
    
    restart();
}
function restart() {

  circle = circle.data(force.nodes());
  circle.enter().append("circle")
    // .attr("class", ".node")
    .attr("class", function(d) { return "node " + d.type; })
    .attr("r", 6)
    .call(force.drag)
    .on("click", handleMouseClick);  

  // // nodeSymb = nodeSymb.data(force.nodes())
  // nodeSymb.data(force.nodes())
  //   .enter()
  //   .append("path")
  //   // .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
  //   .attr("d", d3.svg.symbol()
  //     .type(d3.svg.symbolTypes[5])
  //     .size(55.0))
  //   .attr("class", function(d) { return "node " + d.type; })
  //   .style("fill", "steelblue")
  //   .style("stroke", "white")
  //   .style("stroke-width", "0.0px")
  //   .call(force.drag)
  //   .on("click", handleMouseClick);

  path = path.data(force.links());
  path.enter().append("path")
    .attr("class", function(d) { return "link " + d.type; })
    .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });

  text = text.data(force.nodes());
  text.enter()
    .append("text")
    .attr("x", 8)
    .attr("y", ".31em")
    .text(function(d) { if (d.name.length > 10){return d.name.substr(0, 5) + "..." + d.name.substr(d.name.length - 5, d.name.length);} else return d.name });

  force.start();
}

function txAdd(txToAdd){

  // Check if already added
  if (force.nodes().some(function(elem) {
        return elem.name === txToAdd
      })) return;

  const url = "http://81.25.55.217:6033/tx/?tx="+txToAdd;

  // console.log(url)
  const request = async () => {
    const res = await fetch(url)
    const data = await res.json();
      // .then( res => res.json() )
      // .then( data => {
        // console.log(data) 
    console.log(data)
    txInd = force.nodes().push({name: data.txid, type: "tx"})
    
    for (var el of data.vout){ 
      newNode = {name: String(el.value), type: "", tx_src: data.txid, n: el.n}
      url2 = "http://81.25.55.217:6033/txo/?tx="+data.txid+"&n="+el.n;
      const res2 = await fetch(url2)
      const data2 = await res2.json();
      console.log(data2)
      if (data2.result == "not found"){
        newNode["tx_dst"] = "";
        newNode["type"] = "notfound";
        // Check if this TXO is already added to chart
        i2 = outExistsSrc(newNode["tx_src"], el.n)
        if (i2 != -1)
        {
          newNode = null;
          (force.nodes())[i2]["name"] = String(el.value);
          // link existing node to tx being added
          // console.log(i2)
          links.push({source: txInd-1, target: i2, type: "suit"});
        } 
      } else if (data2.result == "utxo"){
        newNode["tx_dst"] = "";
        newNode["type"] = "utxo";
      } else {
        newNode["tx_dst"] = data2.data[0].tx_dst;
        newNode["type"] = "found";
        // Check if this TXO is already added to chart
        i2 = outExistsSrc(newNode["tx_src"], el.n)
        if (i2 != -1)
        {
          newNode = null;
          (force.nodes())[i2]["name"] = String(el.value);
          // link existing node to tx being added
          // console.log(i2)
          links.push({source: txInd-1, target: i2, type: "suit"});
        } 
        console.log(i2)
      }
    
      // console.log(newNode)
      if (newNode != null){
        nInd = force.nodes().push(newNode); 
        links.push({source: txInd-1, target: nInd - 1, type: "suit"});
        // console.log(el.scriptPubKey.address)
      }
    }

    for (var el of data.vin){ 
      // Check if this TXO is already added to chart
      i2 = outExistsSrc(el.txid, el.vout)
      if (i2 != -1){
        links.push({target: txInd-1, source: i2, type: "suit"});
      } else {
        newNode = {name: String(el.value), type: "found", tx_dst: data.txid, n: el.vout, tx_src: el.txid}
        nInd = force.nodes().push(newNode); 
        links.push({source: nInd - 1, target: txInd - 1, type: "suit"});
        // console.log(el.txid)
      }
    }
    restart();
  }
  request();
  
    // });
}

function outExistsDst(txid, n){
  var i;
  var list = force.nodes();

  console.log(txid,n)
  for (i = 0; i < list.length; i++) {
    // console.log()
    if (list[i].tx_dst == txid && list[i].n == n) {
      console.log("found:",list[i].index)
      return list[i].index;
    }
  }
  return -1;
}

function outExistsSrc(txid, n){
  var i;
  var list = force.nodes();

  console.log(txid,n)
  for (i = 0; i < list.length; i++) {
    if (list[i].tx_src == txid && list[i].n == n) {
      return list[i].index;
    }
  }
  
  return -1;
}
</script>
